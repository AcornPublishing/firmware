<HTML>
<HEADER>
<TITLE>common/monitor/ethernet.c</TITLE>
</HEADER>
<BODY BGCOLOR = #f0f0f0>
<PRE>
<BODY>
/* ethernet.c:
 *  This code supports most of the generic ethernet/IP/ARP/UDP stuff.
 *
 *  General notice:
 *  This code is part of a boot-monitor package developed as a generic base
 *  platform for embedded system designs.  As such, it is likely to be
 *  distributed to various projects beyond the control of the original
 *  author.  Please notify the author of any enhancements made or bugs found
 *  so that all may benefit from the changes.  In addition, notification back
 *  to the author will allow the new user to pick up changes that may have
 *  been made by other users after this version of the code was distributed.
 *
 *  Note1: the majority of this code was edited with 4-space tabs.
 *  Note2: as more and more contributions are accepted, the term "author"
 *         is becoming a mis-representation of credit.
 *
 *  Original author:    Ed Sutter
 *  Email:              esutter@lucent.com
 *  Phone:              908-582-2351
 */
#include "config.h"
#include "endian.h"
#include "stddefs.h"
#include "genlib.h"

#if INCLUDE_ETHERNET
#include "cpuio.h"
#include "ether.h"
#include "monflags.h"
#include "cli.h"

void ShowEthernetStats(void);
void processMONCMD(struct ether_header *,ushort);
int  SendIPMonChar(uchar,int);

#if INCLUDE_DHCPBOOT
#define <A NAME="dhcpStateCheck">dhcpStateCheck</A>()    <A NAME="dhcpStateCheck">dhcpStateCheck</A>()
#define <A NAME="dhcpDisable">dhcpDisable</A>()       <A NAME="dhcpDisable">dhcpDisable</A>()
#define <A NAME="ShowDhcpStats">ShowDhcpStats</A>()     <A NAME="ShowDhcpStats">ShowDhcpStats</A>()
#else
#define <A NAME="dhcpStateCheck">dhcpStateCheck</A>()
#define <A NAME="dhcpDisable">dhcpDisable</A>()
#define <A NAME="ShowDhcpStats">ShowDhcpStats</A>()
#endif

#if INCLUDE_TFTP
#define <A NAME="tftpStateCheck">tftpStateCheck</A>()    <A NAME="tftpStateCheck">tftpStateCheck</A>()
#define <A NAME="tftpInit">tftpInit</A>()          <A NAME="tftpInit">tftpInit</A>()
#define <A NAME="ShowTftpStats">ShowTftpStats</A>()     <A NAME="ShowTftpStats">ShowTftpStats</A>()
#else
#define <A NAME="tftpStateCheck">tftpStateCheck</A>()
#define <A NAME="tftpInit">tftpInit</A>()
#define <A NAME="ShowTftpStats">ShowTftpStats</A>()
#endif


char *Etheradd, *IPadd;     /* Pointers to ascii addresses */
uchar BinIpAddr[4];         /* Space for binary IP address */
uchar BinEnetAddr[6];       /* Space for binary MAC address */
int EtherVerbose;           /* Verbosity flag (see ether.h). */
int EtherIsActive;          /* Non-zero if ethernet is up. */
int EtherIPERRCnt;          /* Number of IP errors detected. */
int EtherUDPERRCnt;         /* Number of UDP errors detected. */
int EtherXFRAMECnt;         /* Number of packets transmitted. */
int EtherRFRAMECnt;         /* Number of packets received. */
int EtherPollNesting;       /* Incremented when pollethernet() is called. */
int MaxEtherPollNesting;    /* High-warter mark of EtherPollNesting. */
int IPMonCmdActive;         /* Set if MONCMD is in progress. */
ushort  UniqueIpId;
struct  ether_header *IPMonCmdHdr;

/* Ports used by the monitor have defaults, but can be redefined using
 * shell variables:
 */
ushort  MoncmdPort;         /* shell var: MCMDPORT */
ushort  DhcpClientPort;     /* shell var: DCLIPORT */
ushort  DhcpServerPort;     /* shell var: DSRVPORT */
ushort  TftpPort;           /* shell var: TFTPPORT */
ushort  TftpSrcPort;        /* shell var: TFTPPORT */

uchar BroadcastAddr[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

struct  pinfo {
    int pnum;
    char    *pname;
} protocols[] = {
        { IP_IP,        "IP" },
        { IP_ICMP,  "ICMP" },
        { IP_IGMP,  "IGMP" },
        { IP_GGP,       "GGP" },
        { IP_TCP,       "TCP" },
        { IP_PUP,       "PUP" },
        { IP_UDP,       "UDP" },
        { 0,0 },
};

char *EtherHelp[] = {
    "Ethernet interface",
    "-[ps:v:V] {on | off | stat}",
    "Options...",
    " -p {1|0}     promiscuous mode (1=on)",
#ifdef SNOOP_ENABLED
    " -s {MAC}     print all packets to/from MAC (snoop)",
#endif
    " -t           self-test ethernet interface",
    " -v {flgs}    enable specific verbosity...",
    "    a: enable ARP trace",
    "    c: print csum errmsg",
    "    C: dump csum errpkt",
    "    d: enable DHCP trace",
    "    i: incoming packets (minus broadcast)",
    "    I: incoming packets (including broadcast)",
    "    o: outgoing packets",
    "    p: phy r/w accesses",
    "    t: enable TFTP trace",
    "    x: enable hex dump (requires i,I or o)",
    "    X: same as 'x' plus ascii",
    " -V        full verbosity (same as -v Iodtx)",
    0
};

int
<A NAME="Ether">Ether</A>(int argc,char *argv[])
{
    int i, len, opt;

    /* Set up some defaults: */
    EtherVerbose = 0;

    while ((opt=<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#getopt>getopt</A>(argc,argv,"p:s:tv:V")) != -1) {
        switch(opt) {
        case 'p':   /* Promiscuous mode: accept all packets */
            if (*optarg == '1')
                <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#enablePromiscuousReception>enablePromiscuousReception</A>();
            else
                <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#disablePromiscuousReception>disablePromiscuousReception</A>();
            return(CMD_SUCCESS);
#ifdef SNOOP_ENABLED
        case 's':
            if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#EtherToBin>EtherToBin</A>(optarg,snoopInfo.mac) &lt; 0)
                return(CMD_FAILURE);
            <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#enablePromiscuousReception>enablePromiscuousReception</A>();
            snoopInfo.on = 1;
            break;
#endif
        case 't':
            <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#enselftest>enselftest</A>(1);
            return(CMD_SUCCESS);
        case 'V':
            EtherVerbose = SHOW_ALL;
            break;
        case 'v':
            len = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strlen>strlen</A>(optarg);
            for(i=0;i&lt;len;i++) {
                switch(optarg[i]) {
                case 'a':
                    EtherVerbose |= SHOW_ARP;
                    EtherVerbose |= SHOW_BROADCAST;
                    break;
                case 'c':
                    EtherVerbose |= SHOW_BADCSUM;
                    break;
                case 'C':
                    EtherVerbose |= SHOW_BADCSUM;
                    EtherVerbose |= SHOW_BADCSUMV;
                    break;
                case 'i':
                    EtherVerbose |= SHOW_INCOMING;
                    break;
                case 'I':
                    EtherVerbose |= SHOW_INCOMING;
                    EtherVerbose |= SHOW_BROADCAST;
                    break;
                case 'o':
                    EtherVerbose |= SHOW_OUTGOING;
                    break;
                case 'p':
                    EtherVerbose |= SHOW_PHY;
                    break;
                case 'd':
                    EtherVerbose |= SHOW_DHCP;
                    break;
                case 't':
                    EtherVerbose |= SHOW_TFTP;
                    break;
                case 'x':
                    EtherVerbose |= SHOW_HEX;
                    break;
                case 'X':
                    EtherVerbose |= SHOW_HEX;
                    EtherVerbose |= SHOW_ASCII;
                    break;
                default:
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Bad 'v' arg\n");
                    return(CMD_PARAM_ERROR);
                }
            }
            break;
        default:
            return(CMD_PARAM_ERROR);
        }
    }

    if (argc != optind+1) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Ethernet interface currently %sabled.\n",
            EtherIsActive ? "en" : "dis");
        return(CMD_SUCCESS);
    }

    if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strcmp>strcmp</A>(argv[optind],"off")) {
        <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#enreset>enreset</A>();
        EtherIsActive = 0;
        return(CMD_SUCCESS);
    }
    else if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strcmp>strcmp</A>(argv[optind],"stat")) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#ShowEthernetStats>ShowEthernetStats</A>();
        <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#ShowEtherdevStats>ShowEtherdevStats</A>();
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/dhcpboot.c.html#ShowDhcpStats>ShowDhcpStats</A>();
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#ShowTftpStats>ShowTftpStats</A>();
        return(CMD_SUCCESS);
    }
    else if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strcmp>strcmp</A>(argv[optind],"on"))
        return(CMD_PARAM_ERROR);

    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#EthernetStartup>EthernetStartup</A>(EtherVerbose,0);
    return(CMD_SUCCESS);
}

void
<A NAME="ShowEthernetStats">ShowEthernetStats</A>(void)
{
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Ethernet currently %s\n",EtherIsActive ? "active" : "off");
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Transmitted frames:      %d\n",EtherXFRAMECnt);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Received frames:         %d\n",EtherRFRAMECnt);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("IP hdr cksum errors:     %d\n",EtherIPERRCnt);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("UDP pkt cksum errors:    %d\n",EtherUDPERRCnt);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Max pollethernet nest:   %d\n",MaxEtherPollNesting);
}

void
<A NAME="DisableEthernet">DisableEthernet</A>(void)
{
    EtherIsActive = 0;
    IPMonCmdActive = 0;
    <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#DisableEtherdev>DisableEtherdev</A>();
}

int
<A NAME="EthernetStartup">EthernetStartup</A>(int verbose, int justreset)
{
    char *ipa;

    /* Initialize the retransmission delay calculator: */
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#RetransmitDelay>RetransmitDelay</A>(DELAY_INIT_DHCP);

    EtherIPERRCnt = 0;
    EtherXFRAMECnt = 0;
    EtherRFRAMECnt = 0;
    EtherUDPERRCnt = 0;
    IPMonCmdActive = 0;
    EtherPollNesting = 0;
    EtherVerbose = verbose;
    MaxEtherPollNesting = 0;
    DHCPState = DHCPSTATE_NOTUSED;

    /* Setup all the IP addresses used by the monitor... */
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#getAddresses>getAddresses</A>() == -1)
        return(-1);

    /* If, after having set up all addresses, the content of the IPADD
     * shell variable is 0.0.0.0, then don't startup ethernet, just return
     * here.
     */
    ipa = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>("IPADD");
    if (ipa) {
        if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strcmp>strcmp</A>(ipa,"0.0.0.0"))
            return(-1);
    }
    else
        return(-1);

    /* Call device specific startup code: */
    <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#EtherdevStartup>EtherdevStartup</A>(verbose);

    /* Initialize some TFTP state... */
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#tftpInit>tftpInit</A>();

#if INCLUDE_DHCPBOOT
    /* If EthernetStartup is called as a result of anything other than a
     * target reset, don't startup any DHCP/BOOTP transaction...
     */
    if (!justreset)
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/dhcpboot.c.html#dhcpDisable>dhcpDisable</A>();
#endif
    EtherIsActive = 1;
    return(0);
}

/* pollethernet():
 *  Called at a few critical points in the monitor code to poll the
 *  ethernet device and keep track of the state of DHCP and TFTP.
 */
int
<A NAME="pollethernet">pollethernet</A>(void)
{
    int pcnt;

    if ((!EtherIsActive) || (EtherPollNesting &gt; 4))
        return(0);

    EtherPollNesting++;
    if (EtherPollNesting &gt; MaxEtherPollNesting)
        MaxEtherPollNesting = EtherPollNesting;

    pcnt = <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#polletherdev>polletherdev</A>();
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/dhcpboot.c.html#dhcpStateCheck>dhcpStateCheck</A>();
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#tftpStateCheck>tftpStateCheck</A>();

    EtherPollNesting--;
    return(pcnt);
}

/* getAddresses():
 * Try getting ether/ip addresses from environment.
 * If not there, try getting them from some target-specific interface.
 * If not there, then get them from raw flash.
 * If not there, just use the hard-coded default.
 * Also, load all port numbers from shell variables, else default.
 *
 * Discussion regarding etheraddr[] and ipaddr[]...
 * The purpose of these two arrays is to provide a point in flash that is 
 * initialized to 0xff by the code (see reset.s).  This then allows some
 * other mechanism (bed of nails, etc..) to program these locations to some
 * other non-0xff value.  It is one of the alternatives provided by the
 * monitor code for storage of IP and MAC.
 */

int
<A NAME="getAddresses">getAddresses</A>(void)
{
    char    *mcmdPort, *dcliPort, *dsrvPort, *tftpPort;

    /* Set up port numbers: */
    mcmdPort = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>("MCMDPORT");
    dcliPort = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>("DCLIPORT");
    dsrvPort = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>("DSRVPORT");
    tftpPort = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>("TFTPPORT");

    if (mcmdPort)
        MoncmdPort = (ushort)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(mcmdPort,0,0);
    else
        MoncmdPort = IPPORT_MONCMD;
    if (dcliPort)
        DhcpClientPort = (ushort)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(dcliPort,0,0);
    else
        DhcpClientPort = IPPORT_DHCP_CLIENT;
    if (dsrvPort)
        DhcpServerPort = (ushort)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(dsrvPort,0,0);
    else
        DhcpServerPort = IPPORT_DHCP_SERVER;
    if (tftpPort)
        TftpPort = (ushort)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(tftpPort,0,0);
    else
        TftpPort = IPPORT_TFTP;             /* 69   */
    TftpSrcPort = IPPORT_TFTPSRC;           /* 8888 */

    /* Retrieve MAC address and store in shell variable ETHERADD...
     * First see if the shell variable is already loaded.
     * If not see if some target-specific interface has it.
     * If not see if the the string is stored in raw flash (usually this
     *   storage is initialized in reset.s of the target-specific code).
     * Finally, as a last resort, use the default set up in config.h.
     */
    if (!(Etheradd = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>("ETHERADD"))) {
        if (!(Etheradd = <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#extGetEtherAdd>extGetEtherAdd</A>())) {
            if (etheraddr[0] != 0xff)
                Etheradd = etheraddr;
            else {
                if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strcmp>strcmp</A>(DEFAULT_ETHERADD,"ETHER_OFF")) {
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Ethernet disabled, must set MAC address\n");
                    return(-1);
                }
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("WARNING: using default MAC address.\n");
                Etheradd = DEFAULT_ETHERADD;
            }
        }
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#setenv>setenv</A>("ETHERADD",Etheradd);
    }

    /* Apply the same logic as above to the IP address... */
    if (!(IPadd = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>("IPADD"))) {
        if (!(IPadd = <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#extGetIpAdd>extGetIpAdd</A>())) {
            if (ipaddr[0] != 0xff)
                IPadd = ipaddr;
            else
                IPadd = DEFAULT_IPADD;
        }
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#setenv>setenv</A>("IPADD",IPadd);
    }

    /* Convert addresses to binary: */
#if INCLUDE_DHCPBOOT
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/dhcpboot.c.html#DhcpIPCheck>DhcpIPCheck</A>(IPadd) == -1)
        return(-1);
#else
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#IpToBin>IpToBin</A>(IPadd,BinIpAddr) &lt; 0)
        return(-1);
#endif
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#EtherToBin>EtherToBin</A>(Etheradd,BinEnetAddr) &lt; 0)
        return(-1);

    /* Initialize a unique number based on MAC: */
    UniqueIpId = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/misc.c.html#xcrc16>xcrc16</A>(BinEnetAddr,6);

    return(0);
}

/* processPACKET():
 *  This is the top level of the message processing after a complete
 *  packet has been received over ethernet.  It's all just a lot of
 *  parsing to determine whether the message is for this board's IP
 *  address (broadcast reception may be enabled), and the type of
 *  incoming protocol.  Once that is determined, the packet is either
 *  processed (TFTP, DHCP, ARP, ICMP-ECHO, etc...) or discarded.
 */
void
<A NAME="processPACKET">processPACKET</A>(struct ether_header *ehdr, ushort size)
{
    int i;
    ushort  *datap, udpport;
    ulong   csum;
    struct ip *ihdr;
    struct Udphdr *uhdr;

    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#printPkt>printPkt</A>(ehdr,size,ETHER_INCOMING);

    if (ehdr-&gt;ether_type == <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ETHERTYPE_ARP)) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/arp.c.html#processARP>processARP</A>(ehdr,size);
        return;
    }
    else if (ehdr-&gt;ether_type == <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ETHERTYPE_REVARP)) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/arp.c.html#processRARP>processRARP</A>(ehdr,size);
        return;
    }
    else if (ehdr-&gt;ether_type != <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ETHERTYPE_IP)) {
        return;
    }

    /* If we are NOT in the middle of a DHCP or BOOTP transaction, then
     * if destination MAC address is broadcast, return now.
     */
#if INCLUDE_DHCPBOOT
    if ((DHCPState == DHCPSTATE_NOTUSED) &&
        (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#memcmp>memcmp</A>((char *)&(ehdr-&gt;ether_dhost),BroadcastAddr,6))) {
        return;
    }
#else
    if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#memcmp>memcmp</A>((char *)&(ehdr-&gt;ether_dhost),BroadcastAddr,6)) {
        return;
    }
#endif

    /* If source MAC address is this board, then assume we received our
     * own outgoing broadcast message...
     */
    if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#memcmp>memcmp</A>((char *)&(ehdr-&gt;ether_shost),BinEnetAddr,6)) {
        return;
    }

    ihdr = (struct ip *) (ehdr + 1);

    /* If not version # 4, return now... */
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ether.h.html#getIP_V>getIP_V</A>(ihdr-&gt;ip_vhl) != 4) {
        return;
    }

    /* IP address filtering:
     * At this point, the only packets accepted are those destined for this
     * board's IP address, plus, DHCP, if active.
     * also accepted.
     */
#if INCLUDE_DHCPBOOT
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#memcmp>memcmp</A>((char *)&(ihdr-&gt;ip_dst),BinIpAddr,4)) {
        if (DHCPState == DHCPSTATE_NOTUSED)
            return;
        if (ihdr-&gt;ip_p != IP_UDP)
            return;
        uhdr = (struct Udphdr *)(ihdr+1);
        if (uhdr-&gt;uh_dport != <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(DhcpClientPort)) {
            return;
        }
    }
#else
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#memcmp>memcmp</A>((char *)&(ihdr-&gt;ip_dst),BinIpAddr,4)) {
        return;
    }
#endif

    /* Verify incoming IP header checksum...
     * Refer to section 3.2 of TCP/IP Illustrated, Vol 1 for details.
     */
    csum = 0;
    datap = (ushort *) ihdr;
    for (i=0;i&lt;(<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct ip)/<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(ushort));i++,datap++)
        csum += *datap;
    csum = (csum & 0xffff) + (csum &gt;&gt; 16);
    if (csum != 0xffff) {
        EtherIPERRCnt++;
        if (EtherVerbose & SHOW_BADCSUM) {
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("IP csum error: 0x%04x != 0xffff\n",(ushort)csum);
            if (EtherVerbose & SHOW_BADCSUMV) {
                int overbose = EtherVerbose;

                EtherVerbose = SHOW_ALL;
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#printPkt>printPkt</A>(ehdr,size,ETHER_INCOMING);
                EtherVerbose = overbose;
            }
        }   
        return;
    }
    
    if (ihdr-&gt;ip_p == IP_ICMP) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/icmp.c.html#processICMP>processICMP</A>(ehdr,size);
        return;
    }
    else if (ihdr-&gt;ip_p == IP_TCP) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/tcpstuff.c.html#processTCP>processTCP</A>(ehdr,size);
        return;
    }
    else if (ihdr-&gt;ip_p != IP_UDP) {
        int j;

        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/icmp.c.html#SendICMPUnreachable>SendICMPUnreachable</A>(ehdr,ICMP_UNREACHABLE_PROTOCOL);
        if (!(EtherVerbose & SHOW_INCOMING))
            return;
        for(j=0;protocols[j].pname;j++) {
            if (ihdr-&gt;ip_p == protocols[j].pnum) {
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("%s not supported\n",
                    protocols[j].pname);
                return;
            }
        }
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("&lt;%02x&gt; protocol unrecognized\n", ihdr-&gt;ip_p);
        return;
    }

    uhdr = (struct Udphdr *)(ihdr+1);

    /* If non-zero, verify incoming UDP packet checksum...
     * Refer to section 11.3 of TCP/IP Illustrated, Vol 1 for details.
     */
    if (uhdr-&gt;uh_sum) {
        int     len;
        struct  UdpPseudohdr    pseudohdr;

        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&pseudohdr.ip_src.s_addr,(char *)&ihdr-&gt;ip_src.s_addr,4);
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&pseudohdr.ip_dst.s_addr,(char *)&ihdr-&gt;ip_dst.s_addr,4);
        pseudohdr.zero = 0;
        pseudohdr.proto = ihdr-&gt;ip_p;
        pseudohdr.ulen = uhdr-&gt;uh_ulen;

        csum = 0;
        datap = (ushort *) &pseudohdr;
        for (i=0;i&lt;(<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct UdpPseudohdr)/<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(ushort));i++)
            csum += *datap++;

        /* If length is odd, pad and add one. */
        len = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(uhdr-&gt;uh_ulen);
        if (len & 1) {
            uchar   *ucp;
            ucp = (uchar *)uhdr;
            ucp[len] = 0;
            len++;
        }
        len &gt;&gt;= 1;

        datap = (ushort *) uhdr;
        for (i=0;i&lt;len;i++)
            csum += *datap++;
        csum = (csum & 0xffff) + (csum &gt;&gt; 16);
        if (csum != 0xffff) {
            EtherUDPERRCnt++;
            if (EtherVerbose & SHOW_BADCSUM) {
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("UDP csum error: 0x%04x != 0xffff\n",(ushort)csum);
                if (EtherVerbose & SHOW_BADCSUMV) {
                    int overbose = EtherVerbose;

                    EtherVerbose = SHOW_ALL;
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#printPkt>printPkt</A>(ehdr,size,ETHER_INCOMING);
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("pseudohdr.ip_src: 0x%08lx\n",
                        pseudohdr.ip_src.s_addr);
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("pseudohdr.ip_dst: 0x%08lx\n",
                        pseudohdr.ip_dst.s_addr);
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("pseudohdr.zero: 0x%02x\n", pseudohdr.zero);
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("pseudohdr.proto: 0x%02x\n", pseudohdr.proto);
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("pseudohdr.ulen: 0x%04x\n", pseudohdr.ulen);
                    EtherVerbose = overbose;
                }
            }   
            return;
        }
    }
    udpport = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(uhdr-&gt;uh_dport);

    if (udpport == MoncmdPort)
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#processMONCMD>processMONCMD</A>(ehdr,size);
#if INCLUDE_DHCPBOOT
    else if (udpport == DhcpClientPort)
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/dhcpboot.c.html#processDHCP>processDHCP</A>(ehdr,size);
#endif
#if INCLUDE_TFTP
    else if ((udpport == TftpPort) || (udpport == TftpSrcPort))
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/tftp.c.html#processTFTP>processTFTP</A>(ehdr,size);
#endif
    else {
        if (EtherVerbose & SHOW_INCOMING) {
            uchar *cp;
            cp = (uchar *)&(ihdr-&gt;ip_src);
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Unexpected IP pkt from %d.%d.%d.%d ",
                cp[0],cp[1],cp[2],cp[3]);
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("(sport=0x%x,dport=0x%x)\n",
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(uhdr-&gt;uh_sport),<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(uhdr-&gt;uh_dport));
        }
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/icmp.c.html#SendICMPUnreachable>SendICMPUnreachable</A>(ehdr,ICMP_UNREACHABLE_PORT);
    }
}

void
<A NAME="processMONCMD">processMONCMD</A>(struct ether_header *ehdr,ushort size)
{
    struct  ip *ihdr;
    struct  Udphdr *uhdr;
    char    *moncmd;
    uchar   *src;

    ihdr = (struct ip *)(ehdr + 1);
    uhdr = (struct Udphdr *)(ihdr + 1);
    moncmd = (char *)(uhdr + 1);
    IPMonCmdHdr = ehdr;
    src = (uchar *)&ihdr-&gt;ip_src;
    if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/monflags.h.html#MFLAGS_NOMONCMDPRN>MFLAGS_NOMONCMDPRN</A>())
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("MONCMD (from %d.%d.%d.%d): ", src[0],src[1],src[2],src[3]);
    IPMonCmdActive = 1;
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/docmd.c.html#docommand>docommand</A>(moncmd,1);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#SendIPMonChar>SendIPMonChar</A>(0,1);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/misc.c.html#stkchk>stkchk</A>("Post-sendIPmonchar");
    IPMonCmdActive = 0;
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/misc.c.html#writeprompt>writeprompt</A>();
}

int
<A NAME="SendIPMonChar">SendIPMonChar</A>(uchar c, int done)
{
    static  int idx;
    static  char linebuf[128];
    int len, hdrlen;
    struct ether_header *te;
    struct ip *ti, *ri;
    struct Udphdr *tu, *ru;

    if (!IPMonCmdActive)
        return(0);

    /* While inside this function, clear the IPMonCmdActive flag to avoid
     * recursion if an error message is to be printed...
     */
    IPMonCmdActive = 0;

    if (idx &gt;= 128) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("SendIPMonChar() overflow.\n");
        IPMonCmdActive = 1;
        return(-1);
    }

    linebuf[idx++] = c;
    if ((!done) && (c != '\n')) {
        IPMonCmdActive = 1;
        return(0);
    }

    hdrlen = <A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct ip) + <A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct Udphdr);
    len = idx + hdrlen ;

    te = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#EtherCopy>EtherCopy</A>(IPMonCmdHdr);

    ti = (struct ip *) (te + 1);
    ri = (struct ip *) (IPMonCmdHdr + 1);
    ti-&gt;ip_vhl = ri-&gt;ip_vhl;
    ti-&gt;ip_tos = ri-&gt;ip_tos;
    ti-&gt;ip_len = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(len);
    ti-&gt;ip_id = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#ipId>ipId</A>();
    ti-&gt;ip_off = ri-&gt;ip_off;
    ti-&gt;ip_ttl = UDP_TTL;
    ti-&gt;ip_p = IP_UDP;
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&(ti-&gt;ip_src.s_addr),(char *)&(ri-&gt;ip_dst.s_addr),
        <A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct in_addr));
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&(ti-&gt;ip_dst.s_addr),(char *)&(ri-&gt;ip_src.s_addr),
        <A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct in_addr));

    tu = (struct Udphdr *) (ti + 1);
    ru = (struct Udphdr *) (ri + 1);
    tu-&gt;uh_sport = ru-&gt;uh_dport;
    tu-&gt;uh_dport = ru-&gt;uh_sport;
    tu-&gt;uh_ulen = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>((ushort)(<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct Udphdr) + idx));
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)(tu+1),linebuf,idx);

    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#ipChksum>ipChksum</A>(ti);       /* Compute checksum of ip hdr */
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#udpChksum>udpChksum</A>(ti);      /* Compute UDP checksum */

    <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#sendBuffer>sendBuffer</A>(MONRESPSIZE);
    idx = 0;
    IPMonCmdActive = 1;
    return(1);
}

/*
 *  printMem(p,n)
 */
void
<A NAME="printMem">printMem</A>(uchar *base, int size)
{
    int i, col;
    uchar *cp, *cp1;

    if (!(EtherVerbose & SHOW_HEX))
        return;

    cp = cp1 = base;
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  ");
    for(col=1,i=0;i&lt;size;i++,col++) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("%02x ",*cp++);
        if ((col == 8) || (col == 16)) {
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  ");
            if (col == 16) {
                col = 0;
                if (EtherVerbose & SHOW_ASCII)
                    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/misc.c.html#prascii>prascii</A>(cp1,16);
                cp1 += 16;
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("\n  ");
            }
        }
    }
    if ((EtherVerbose & SHOW_ASCII) && (col &gt; 1)) {
        int space;

        space = (3 * (17 - col)) + (col &lt;= 8 ? 4 : 2);
        while(space--)
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/chario.c.html#putchar>putchar</A>(' ');
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/misc.c.html#prascii>prascii</A>(cp1,col-1);
    }
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("\n");
    return;
}

/*
 *  printPkt(ehdr,len)
 */
void
<A NAME="printPkt">printPkt</A>(struct ether_header *ehdr, int len, int direction)
{
    struct  arphdr *arpp;
    char    *dir;

    /* Filter based on verbosity level... */
    if (direction == ETHER_INCOMING) {
        if (!(EtherVerbose & SHOW_INCOMING))
            return;
        dir = "INCOMING";
    }
    else if (direction == ETHER_OUTGOING) {
        if (!(EtherVerbose & SHOW_OUTGOING))
            return;
        dir = "OUTGOING";
    }
    else {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("printPkt() direction error\n");
        dir = "???";
    }

    /* If direction is incoming and SHOW_BROADCAST is not set, then */
    /* return here if the destination host is broadcast. */
    if ((direction == ETHER_INCOMING) &&
        (!(EtherVerbose & SHOW_BROADCAST)) &&
        (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#memcmp>memcmp</A>(ehdr-&gt;ether_dhost.ether_addr_octet,BroadcastAddr,6)))
        return;

    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("\n%s PACKET (%d bytes):\n",dir,len);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#printMem>printMem</A>((char *)ehdr,len);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Destination Host = %02x:%02x:%02x:%02x:%02x:%02x\n",
        ehdr-&gt;ether_dhost.ether_addr_octet[0],
        ehdr-&gt;ether_dhost.ether_addr_octet[1],
        ehdr-&gt;ether_dhost.ether_addr_octet[2],
        ehdr-&gt;ether_dhost.ether_addr_octet[3],
        ehdr-&gt;ether_dhost.ether_addr_octet[4],
        ehdr-&gt;ether_dhost.ether_addr_octet[5]);

    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Source Host =      %02x:%02x:%02x:%02x:%02x:%02x\n",
        ehdr-&gt;ether_shost.ether_addr_octet[0],
        ehdr-&gt;ether_shost.ether_addr_octet[1],
        ehdr-&gt;ether_shost.ether_addr_octet[2],
        ehdr-&gt;ether_shost.ether_addr_octet[3],
        ehdr-&gt;ether_shost.ether_addr_octet[4],
        ehdr-&gt;ether_shost.ether_addr_octet[5]);


    switch (ehdr-&gt;ether_type) {
    case <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ETHERTYPE_IP):
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#printIp>printIp</A>((struct ip *)(ehdr+1));
        break;
    case <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ETHERTYPE_PUP):
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Type = PUP\n");
        break;
    case <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ETHERTYPE_ARP):
        arpp = (struct arphdr *)(ehdr+1);
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Type = ARP %s from IP %d.%d.%d.%d)\n",
            arpp-&gt;operation == <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ARP_RESPONSE) ? "RESPONSE" : "REQUEST",
            arpp-&gt;senderia[0],arpp-&gt;senderia[1],
            arpp-&gt;senderia[2],arpp-&gt;senderia[3]);
        break;
    case <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(ETHERTYPE_REVARP):
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Type = REVARP\n");
        break;
    default:
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Type = 0x%04x ???\n", ehdr-&gt;ether_type);
        break;
    }
}

/*
 *  printIp(p)
 */
int
<A NAME="printIp">printIp</A>(struct ip *ihdr)
{
    int i;
    struct ip *icpy;
    char    buf[16], buf1[16];
    ulong   tmp[<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct ip)/2];

    /* Copy data to aligned memory space so printf doesn't crash. */
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)tmp,(char *)ihdr,<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct ip));
    icpy = (struct ip *)tmp;
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  IP:  vhl/tos  len    id     offset  ttl/proto  csum\n");
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("       x%02x%02x    x%04x  x%04x  x%04x   x%02x%02x      x%04x\n",
        icpy-&gt;ip_vhl,icpy-&gt;ip_tos, <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(icpy-&gt;ip_len),
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(icpy-&gt;ip_id), <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(icpy-&gt;ip_off),
        icpy-&gt;ip_ttl, icpy-&gt;ip_p, <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(icpy-&gt;ip_sum));

    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("       src          dest\n");
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("       %s  %s\n",
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#IpToString>IpToString</A>(icpy-&gt;ip_src.s_addr,buf),
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#IpToString>IpToString</A>(icpy-&gt;ip_dst.s_addr,buf1));

    if (icpy-&gt;ip_p == IP_UDP) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#printUdp>printUdp</A>((struct Udphdr *)(ihdr+1));
        return(0);
    }
    for(i=0;protocols[i].pname;i++) {
        if (icpy-&gt;ip_p == protocols[i].pnum) {
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  Protocol: %s\n",protocols[i].pname);
            return(0);
        }
    }
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  &lt;%02x&gt;: unknown IP protocol\n", icpy-&gt;ip_p);
    return (1);
}

/*
 *  printUdp(p)
 */
int
<A NAME="printUdp">printUdp</A>(struct Udphdr *p)
{
    ushort  dport, sport;

    dport = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(p-&gt;uh_dport);
    sport = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(p-&gt;uh_sport);

#if INCLUDE_DHCPBOOT
    if ((dport == DhcpServerPort) || (dport == DhcpClientPort)) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/dhcpboot.c.html#printDhcp>printDhcp</A>(p);
        return(0);
    }
#endif
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("  UDP: sport dport ulen sum\n");
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("       %4d  %4d  %4d %4d\n",
        sport, dport, <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(p-&gt;uh_ulen),<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(p-&gt;uh_sum));
    return(0);
}

int
<A NAME="IpToBin">IpToBin</A>(char *ascii,uchar *binary)
{
    int i, digit;
    char    *acpy;

    acpy = ascii;
    for(i=0;i&lt;4;i++) {
        digit = (int)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(acpy,&acpy,10);
        if (((i != 3) && (*acpy++ != '.')) ||
            ((i == 3) && (*acpy != 0)) ||
            (digit &lt; 0) || (digit &gt; 255)) {
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Misformed IP addr: %s\n",ascii);
            return(-1);
        }
        binary[i] = (uchar)digit;
    }
    return(0);
}

/* IpToString():
 *  Incoming ascii pointer is assumed to be pointing to at least 16
 *  characters of available space.  Conversion from long to ascii is done
 *  and string is terminated with NULL.  The ascii pointer is returned.
 */
char *
<A NAME="IpToString">IpToString</A>(ulong ipadd,char *ascii)
{
    uchar   *cp;

    cp = (uchar *)&ipadd;
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#sprintf>sprintf</A>(ascii,"%d.%d.%d.%d",
        (int)cp[0],(int)cp[1],(int)cp[2],(int)cp[3]);
    return(ascii);
}

char *
<A NAME="EtherToString">EtherToString</A>(uchar *etheradd,char *ascii)
{
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#sprintf>sprintf</A>(ascii,"%02x:%02x:%02x:%02x:%02x:%02x",(int)etheradd[0],
        (int)etheradd[1],(int)etheradd[2],(int)etheradd[3],
        (int)etheradd[4],(int)etheradd[5]);
    return(ascii);
}

/* ipChksum():
 *  Compute the checksum of the IP header.
 *  The incoming pointer to an IP header is directly populated with
 *  the result.
 */
void
<A NAME="ipChksum">ipChksum</A>(struct ip *ihdr)
{
    register int    i;
    register ushort *sp;
    register long   csum;

    csum = 0;
    ihdr-&gt;ip_sum = 0;
    sp = (ushort *) ihdr;
    for (i=0;i&lt;((int)<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct ip)/(int)<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(ushort));i++,sp++) {
        csum += *sp;
        if (csum & 0x80000000)
            csum = (csum & 0xffff) + (csum &gt;&gt; 16);
    }
    while(csum &gt;&gt; 16)
        csum = (csum & 0xffff) + (csum &gt;&gt; 16);
    ihdr-&gt;ip_sum = ~csum;
}

/*  udpChksum():
 *  Compute the checksum of the UDP packet.
 *  The incoming pointer is to an ip header, the udp header after that ip
 *  header is directly populated with the result.
 *  Got part of this code out of Steven's TCP/IP Illustrated Volume 2.
 */
void
<A NAME="udpChksum">udpChksum</A>(struct ip *ihdr)
{
    register int    i;
    register ushort *datap;
    register long   sum;
    int     len;
    struct  Udphdr *uhdr;
    struct  UdpPseudohdr    pseudohdr;

    uhdr = (struct Udphdr *)(ihdr+1);
    uhdr-&gt;uh_sum = 0;

    /* Note that optionally, the checksum can be forced to zero here,
     * so a return could replace the remaining code.
     * That would be kinda dangerous, but it is an option according to
     * the spec.
     */

    /* Start with the checksum of the pseudo header:
     * Note that we have to use memcpy because we don't know if the incoming
     * stream is aligned properly.
     */
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&pseudohdr.ip_src.s_addr,(char *)&ihdr-&gt;ip_src.s_addr,4);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&pseudohdr.ip_dst.s_addr,(char *)&ihdr-&gt;ip_dst.s_addr,4);
    pseudohdr.zero = 0;
    pseudohdr.proto = ihdr-&gt;ip_p;
    pseudohdr.ulen = uhdr-&gt;uh_ulen;

    /* Get checksum of pseudo header: */
    sum = 0;
    datap = (ushort *) &pseudohdr;
    for (i=0;i&lt;(<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(struct UdpPseudohdr)/<A HREF=FILE:/TOP_DIRNAME/src/common/cpu/mpc860.h.html#sizeof>sizeof</A>(ushort));i++) {
        sum += *datap++;
        if (sum & 0x80000000)
            sum = (sum & 0xffff) + (sum &gt;&gt; 16);
    }

    len = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/endian.h.html#ecs>ecs</A>(uhdr-&gt;uh_ulen);
    datap = (ushort *) uhdr;

    /* If length is odd, pad with zero and add 1... */
    if (len & 1) {
        uchar   *ucp;
        ucp = (uchar *)uhdr;
        ucp[len] = 0;
        len++;
    }

    while(len) {
        sum += *datap++;
        if (sum & 0x80000000)
            sum = (sum & 0xffff) + (sum &gt;&gt; 16);
        len -= 2;
    }

    while(sum &gt;&gt; 16)
        sum = (sum & 0xffff) + (sum &gt;&gt; 16);

    uhdr-&gt;uh_sum = ~sum;
}

struct  ether_header *
<A NAME="EtherCopy">EtherCopy</A>(struct ether_header *re)
{
    struct  ether_header *te;

    te = (struct ether_header *) <A HREF=FILE:/TOP_DIRNAME/src/targets/target_dirname/monitor/etherdev.c.html#getXmitBuffer>getXmitBuffer</A>();
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&(te-&gt;ether_shost),(char *)&(re-&gt;ether_dhost),6);
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/cstart.c.html#memcpy>memcpy</A>((char *)&(te-&gt;ether_dhost),(char *)&(re-&gt;ether_shost),6);
    te-&gt;ether_type = re-&gt;ether_type;
    return(te);
}

ushort
<A NAME="ipId">ipId</A>(void)
{
    return(++UniqueIpId);
}


/* getTuneup():
 *  The DHCP, TFTP and ARP timeout & retry mechanism can be tuned based on
 *  the content of the shell variables DHCPRETRYTUNE, TFTPRETRYTUNE and
 *  ARPRETRYTUNE respectively.
 *  Return 0 if variable is not found, -1 if there is a detected error in
 *  the content of the shell variable; else 1 indicating that the three
 *  parameters have been loaded from the content of the shell variable.
 */
int
<A NAME="getTuneup">getTuneup</A>(char *varname,int *rexmitdelay,int *giveupcount,int *rexmitdelaymax)
{
    char *vp, *colon1, *colon2;
    
    vp = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/env.c.html#getenv>getenv</A>(varname);
    if (!vp)
        return(0);
    colon1 = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strchr>strchr</A>(vp,':');
    if (colon1) {
        colon2 = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strchr>strchr</A>(colon1+1,':');
        if (colon2) {
            *rexmitdelay = (int)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(vp,0,0);
            *giveupcount = (int)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(colon1+1,0,0);
            *rexmitdelaymax = (int)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(colon2+1,0,0);
            return(1);
        }
    }
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Syntax error in %s\n",varname);
    return(-1);
}

/* RetransmitDelay():
 *  This function provides a common point for retransmission delay
 *  calculation.  It is an implementation "similar" to the recommendation
 *  made in the RFC 2131 (DHCP) section 4.1 paragraph #8...
 *
 *  The delay before the first retransmission is 4 seconds randomized by
 *  the value of a uniform random number chosen from the range -1 to +2.
 *  The delay before the next retransmission is 8 seconds randomized by
 *  the same number as previous randomization.  Each subsequent retransmission
 *  delay is doubled up to a maximum of 66 seconds.  Once a delay of 66
 *  seconds is reached, return that value for for 6 subsequent delay
 *  requests, then return RETRANSMISSION_TIMEOUT (-1) indicating that the
 *  requestor should give up.
 *
 *  The value of randomdelta will be 2, 1, 0 or -1 depending on the target's
 *  IP address.
 *
 *  The return values will be...
 *  4+randomdelta, 8+randomdelta, 16+randomdelta, etc... up to 64+randomdelta.
 *  Then after returning 64+randomdelta 6 times, return RETRANSMISSION_TIMEOUT.
 *
 *  NOTE: if DELAY_RETURN is the opcode, then RETRANSMISSION_TIMEOUT is
 *        never returned, once the max is reached, it is always the value
 *        returned;
 *        if DELAY_OR_TIMEOUT_RETURN is the opcode, then once maxoutcount
 *        reaches 6, RETRANSMISSION_TIMEOUT is returned.
 *
 *  NOTE1: this function supports the ability to modify the above-discussed
 *         parameters.  Start with DELAY_INIT_DHCP to set up the parameters
 *         discussed above; start with DELAY_INIT_XXXX for others.
 */
int
<A NAME="RetransmitDelay">RetransmitDelay</A>(int opcode)
{
    static int randomdelta;     /* Used to slightly randomize the delay.
                                 * Taken from the 2 least-significant-bits
                                 * of the IP address (range = -1 to 2).
                                 */
    static int rexmitdelay;     /* Doubled each time DELAY_INCREMENT
                                 * is called until it is greater than the
                                 * value stored in rexmitdelaymax.
                                 */
    static int rexmitdelaymax;  /* See rexmitdelay. */
    static int maxoutcount;     /* Number of times the returned delay has
                                 * reached its max.
                                 */
    static int giveupcount;     /* Once maxoutcount reaches this value, we
                                 * give up and return TIMEOUT.
                                 */
    int     rexmitstate;

    rexmitstate = RETRANSMISSION_ACTIVE;
    switch(opcode) {
        case DELAY_INIT_DHCP:       
            if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#getTuneup>getTuneup</A>("DHCPRETRYTUNE",&rexmitdelay,
                &giveupcount,&rexmitdelaymax) &lt;= 0) {
                rexmitdelay = 4;
                giveupcount = 6;
                rexmitdelaymax = 64;
            }
            maxoutcount = 0;
            randomdelta = (int)(BinIpAddr[3] & 3) - 1;
            break;
        case DELAY_INIT_TFTP:
            if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#getTuneup>getTuneup</A>("TFTPRETRYTUNE",&rexmitdelay,
                &giveupcount,&rexmitdelaymax) &lt;= 0) {
                rexmitdelay = 4;
                giveupcount = 3;
                rexmitdelaymax = 32;
            }
            maxoutcount = 0;
            randomdelta = (int)(BinIpAddr[3] & 3) - 1;
            break;
        case DELAY_INIT_ARP:
            if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/ethernet.c.html#getTuneup>getTuneup</A>("ARPRETRYTUNE",&rexmitdelay,
                &giveupcount,&rexmitdelaymax) &lt;= 0) {
                rexmitdelay = 1;    
                giveupcount = 0;
                rexmitdelaymax = 4;
            }
            maxoutcount = 0;
            randomdelta = 0;
            break;
        case DELAY_INCREMENT:
            if (rexmitdelay &lt; rexmitdelaymax)
                rexmitdelay &lt;&lt;= 1;      /* double it. */
            else 
                maxoutcount++;

            if (maxoutcount &gt; giveupcount)
                rexmitstate = RETRANSMISSION_TIMEOUT;
            break;
        case DELAY_OR_TIMEOUT_RETURN:
            if (maxoutcount &gt; giveupcount)
                rexmitstate = RETRANSMISSION_TIMEOUT;
            break;
        case DELAY_RETURN:
            break;
        default:
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("\007TimeoutAlgorithm error 0x%x.\n",opcode);
            rexmitstate = RETRANSMISSION_TIMEOUT;
            break;
    }
    if (rexmitstate == RETRANSMISSION_TIMEOUT)
        return(RETRANSMISSION_TIMEOUT);
    else
        return(rexmitdelay+randomdelta);
}

#endif

/* EtherToBin():
 *  Convert ascii MAC address string to binary.  Note that this is outside
 *  the #if INCLUDE_ETHERNET because it is used by password.c.  This correctly
 *  implies that if there is no ethernet interface, then we need a different
 *  solution for the password backdoor!.
 */
int
<A NAME="EtherToBin">EtherToBin</A>(char *ascii,uchar *binary)
{
    int i, digit;
    char    *acpy;

    acpy = ascii;
    for(i=0;i&lt;6;i++) {
        digit = (int)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(acpy,&acpy,16);
        if (((i != 5) && (*acpy++ != ':')) ||
            ((i == 5) && (*acpy != 0)) ||
            (digit &lt; 0) || (digit &gt; 255)) {
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Misformed ethernet addr: %s\n",ascii);
            return(-1);
        }
        binary[i] = (uchar)digit;
    }
    return(0);
}

</HTML>
</PRE>
</BODY>
