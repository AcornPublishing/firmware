<HTML>
<HEADER>
<TITLE>common/monitor/fpga.c</TITLE>
</HEADER>
<BODY BGCOLOR = #f0f0f0>
<PRE>
<BODY>
/*
 * fpga.c
 *
 * Xilinx FPGA programming module.
 * This code uses GPIOs to program the Xilinx SpartanII family of FPGA
 * using the slave paraller mode to load the bit file.
 * It recognizes as input the .bit file generated by the VHDL compiler,
 * and expects an address of where the file is located in memory as argument.
 *
 * by Thomas E. Arvanitis (tharvan@inaccessnetworks.com)
 * by Dimitris Economou (decon@inaccessnetworks.com)
 */

#include "config.h"

#if INCLUDE_FPGA

#include "SA-1100.h"
#include "fpga.h"
#include "genlib.h"
#include "stddefs.h"
#include "monapp.h"
#include "tfs.h"
#include "tfsprivate.h"

void 
<A NAME="set_gpio_dirpin">set_gpio_dirpin</A>(int pin, int dir)
{
    unsigned long reg_val;
    reg_val = 0;
    reg_val = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#rdreg>rdreg</A>(&GPDR);

    switch(dir){
    case 1:
        reg_val |= (1&lt;&lt;pin);
        break;
    case 0:
        reg_val &= ~(1&lt;&lt;pin);
        break;
    default:
        ;
    }
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#wrreg>wrreg</A>(&GPDR, reg_val);
}

void 
<A NAME="set_gpio_setpin">set_gpio_setpin</A>(int pin)
{

    GPSR |= (1&lt;&lt;pin);
}

void 
<A NAME="set_gpio_clspin">set_gpio_clspin</A>(int pin)
{
    
    GPCR |= (1&lt;&lt;pin);
}

unsigned long 
<A NAME="check_gpio_pin">check_gpio_pin</A>(int pin)
{
    unsigned long reg_val, ret_val;
    reg_val = 0;
    reg_val = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#rdreg>rdreg</A>(&GPLR);

    ret_val = reg_val & (1&lt;&lt;pin);

    return ret_val;
}


void 
<A NAME="udelay">udelay</A>(int us)
{
    volatile int i;
    int loops;

    loops = us * LoopsPerSecond/1000000;
    
    for (i=0; i&lt;loops; i++);
}

/*
 * XILINX clean memory:
 * Initiate a memory clean configuration cycle
 */
int
<A NAME="fpga_mem_clean">fpga_mem_clean</A>(void)
{
   unsigned long reg_val;

   reg_val = 0;
   reg_val = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#rdreg>rdreg</A>(&GPDR);

   <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#set_gpio_dirpin>set_gpio_dirpin</A>(FPGA_PROG_PIN, OUTDIR);
   <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#set_gpio_dirpin>set_gpio_dirpin</A>(FPGA_INIT_PIN, INDIR);

   <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#set_gpio_clspin>set_gpio_clspin</A>(FPGA_PROG_PIN);

   <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#udelay>udelay</A>(WAIT_TIME);

   <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#set_gpio_setpin>set_gpio_setpin</A>(FPGA_PROG_PIN);

   <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#D>D</A>(if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#check_gpio_pin>check_gpio_pin</A>(FPGA_INIT_PIN))
       <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("After PROGRAM goes HIGH INIT stays LOW for a while\n");)

   /*
    * Wait until the init goes down,
    * means mem is clear.
    */
   while (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#check_gpio_pin>check_gpio_pin</A>(FPGA_INIT_PIN));

   return OK;
}


/*
 * XILINX programing mode:
 * Enter the fpga programming mode.
 * Download a byte sequence located at address_in.
 */
int 
<A NAME="fpga_program">fpga_program</A>(unsigned long *address_in)
{
    register int i, j, k, cnt;
    register unsigned char xbuf, tmp, rbyte;
    register unsigned char *dst;
    register unsigned long *buf;
    register unsigned long ltmp;
    int bitf_ok;
    
    buf = address_in;
    dst = (unsigned char *) FPGA_PROG_ADDR;

    /*
     * Search for the dummy byte in the bit file,
     * and start from there on, to skip the embedded useless header
     * of the bit file.
     *
     * We only search the first 512 bytes, else it is obvious
     * it is not a bit file.
     */
    bitf_ok = 0;
    cnt = 0;
    while ((cnt &lt; 4) && (buf &lt; address_in+0x200)) {
        for (j=0; j&lt;4; j++) {
            ltmp = *buf &gt;&gt; (j*8);
            xbuf = (unsigned char) (ltmp & 0xff);

            if (xbuf == XLNX_DBYTE) {
                cnt++;
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#D>D</A>(<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Address of buf = 0x%08x\n", buf);)
            } else
                cnt = 0;

            if (cnt == 4) {
                bitf_ok = 1;
                break;
            }
        }
        buf++;
    }

    if (bitf_ok == 0)
        return ERR_BITF;

    buf--; /* go back one word */
    j++;

    /* buf has the address of current word and j points
       first byte after the DUMMY WORD*/
    
    for (k=0; k&lt;4; k++) {/* Write the DUMMY WORD*/
        *dst = XLNX_DBYTE;
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#D>D</A>(<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Downloaded word: 0x%x\n", XLNX_DBYTE);)
    }
    
    for (; j&lt;4; j++) {
        rbyte = 0;
        ltmp = *buf &gt;&gt; (j*8);
        xbuf = (unsigned char) (ltmp & 0xff);
            
        for (k=0; k&lt;8; k++) {
            tmp = xbuf &gt;&gt; k;
            tmp &= 1;
            rbyte |= tmp&lt;&lt;(7-k);
        }
        *dst = rbyte;

        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#D>D</A>(<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Downloaded word: 0x%x\n", rbyte);)
    }

    buf++; /* Buf points to the next of DUMMY_WORD word */
    
    for (i=0; i&lt;FPGA_BYTE_LENGTH/4; i++) {
        /* Reverse byte endianess */
        for (j=0; j&lt;4; j++) {
            rbyte = 0;
            ltmp = *buf &gt;&gt; (j*8);
            xbuf = (unsigned char) (ltmp & 0xff);
            for (k=0; k&lt;8; k++) {
                tmp = xbuf &gt;&gt; k;
                tmp &= 1;
                rbyte |= tmp&lt;&lt;(7-k);
            }
            *dst = rbyte;

            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.h.html#D>D</A>(if (i&lt;5) {
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Downloaded word: 0x%x\n", rbyte);
            })
            
        }

        buf++;
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#udelay>udelay</A>(WAIT_WRITE);
    }

    /* More accesses on FPGA_PROG_ADDR 
       in order to pass the startup phase */
    
    for (i=0; i&lt;10; i++) {
        *dst = 0;
    }
    
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#udelay>udelay</A>(WAIT_TIME);

    if (!<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#check_gpio_pin>check_gpio_pin</A>(FPGA_INIT_PIN)){
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("fpga error: INIT is LOW. It has to be HIGH\n");
        return ERROR;
    }
    return OK;
}


char *XlnxHelp[] = {
    "Xilinx Spartan-II programming",
    "-[c] -[p:] -[f:]",
    "",
    "Options:",
    "-c clear configuration memory",
    "-p addr    program loading directly from addr",
    "-f file    program reading from TFS file",
    "",
    "addr: source address in hex of Xilinx bit file.",
    "file: filename of bit file in TFS.",
    "",
    "NOTE: In both programming modes -c is implicitly applied",
    0
};

int 
<A NAME="Xlnx">Xlnx</A>(int argc, char *argv[])
{
    unsigned long *address, *pr_addr;
    char *filename;
    int opt, addr_prog, file_prog, clear_mem;
    int rval;
    TFILE *fp;

    if (argc &lt; 2) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("No arguments, exiting... use help\n");
        return(0);
    }

    addr_prog = file_prog = clear_mem = 0;

    while((opt=<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#getopt>getopt</A>(argc,argv,"cf:p:")) != -1) {
        switch(opt) {
            case 'c':
                clear_mem = 1;
                break;
            case 'f':
                filename = optarg;
                file_prog = 1;
                break;
            case 'p':
                address = (unsigned long *)(<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/genlib.c.html#strtol>strtol</A>(optarg, (char **)0, 16));
                addr_prog = 1;
                break;
            default:
                return(0);
        }
    }
    
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Cleaning FPGA memory... ");
    if (<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#fpga_mem_clean>fpga_mem_clean</A>() &lt; 0) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("xlnx error: not cleaned\n");
        return(0);
    }
    <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("OK\n");
    
    if (addr_prog) {
        pr_addr = address;
    } else if (file_prog){
        fp = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/tfs.c.html#tfsstat>tfsstat</A>(filename);
        if (fp == 0) {
            <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("xlnx error: file %s not found!\n", filename);
            return(0);
        }
        pr_addr = (unsigned long *)<A HREF=FILE:/TOP_DIRNAME/src/common/monitor/tfs.h.html#TFS_BASE>TFS_BASE</A>(fp);
    }

    if (addr_prog || file_prog) {
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("Programming FPGA memory... ");
        if ((rval = <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/fpga.c.html#fpga_program>fpga_program</A>(pr_addr)) &lt; 0) {
            if (rval == ERR_BITF) {
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("xlnx error: invalid bit file\n");
            } else {
                <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("xlnx error: failed\n");
            }
            return(0);
        }
        <A HREF=FILE:/TOP_DIRNAME/src/common/monitor/mprintf.c.html#printf>printf</A>("OK\n");
    }

    return(0);
}

#endif
</HTML>
</PRE>
</BODY>
